Lo aprendido durante el desarrollo:

Aprendizaje sobre manipulación de archivos en Java: 
A través de este proyecto, gané experiencia en la lectura y escritura de archivos en Java utilizando las clases File, 
BufferedReader, BufferedWriter, FileReader y FileWriter. Entendí cómo trabajar con diferentes tipos de archivos y 
manejar excepciones relacionadas con operaciones de archivos.

Trabajo con colecciones y flujos de datos: 
Utilicé colecciones como List para almacenar información sobre productos 
y vendedores, y aprendí cómo manipular estos datos de manera eficiente utilizando bucles y métodos de colección en Java. 
También practiqué el uso de flujos de datos para leer y escribir información de manera secuencial.

Generación de datos aleatorios: Implementé la generación de ventas aleatorias, lo que me permitió practicar la generación 
de números aleatorios en Java y cómo integrarlos en un flujo de trabajo más grande.

Posibles aplicaciones en mi vida profesional:
Desarrollo de aplicaciones de gestión de datos: 
Los conocimientos adquiridos en este proyecto son fundamentales para desarrollar aplicaciones que manipulen grandes volúmenes 
de datos, como sistemas de gestión de inventario, sistemas de contabilidad, y sistemas de gestión de ventas.
Automatización de tareas de procesamiento de datos: La capacidad para leer y escribir archivos de manera programática es 
esencial para la automatización de tareas repetitivas en entornos profesionales, como la generación de informes, 
la migración de datos y la integración de sistemas.

Desarrollo de aplicaciones de análisis de datos: 

La experiencia en la manipulación de datos y la generación de datos aleatorios puede ser útil en el desarrollo de aplicaciones 
de análisis de datos y simulación, donde se requiere trabajar con conjuntos de datos grandes y realizar cálculos complejos.

Dificultades durante el desarrollo del proyecto:
Manejo de excepciones: Uno de los desafíos fue comprender y manejar adecuadamente las excepciones que pueden surgir durante 
la lectura y escritura de archivos, así como durante otras operaciones de entrada/salida.

Diseño y organización del código: 
A medida que el proyecto crecía, surgió la necesidad de organizar el código de manera más eficiente para mantenerlo claro y fácil de entender.
 
Esto implicó decisiones sobre la estructura del proyecto, la división en clases y métodos, y la gestión de dependencias entre componentes.

Pruebas y depuración: Asegurarse de que el programa funcione correctamente en diferentes escenarios y manejar errores inesperados durante 
la ejecución del programa fueron desafíos importantes. Esto requería realizar pruebas exhaustivas y utilizar técnicas efectivas de depuración 
para identificar y solucionar problemas.